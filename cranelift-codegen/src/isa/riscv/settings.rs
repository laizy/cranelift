//! RISC-V Settings.

use crate::settings::{self, detail, Builder};
use core::fmt;

// Include code generated by `cranelift-codegen/meta/src/gen_settings.rs`. This file contains a
// public `Flags` struct with an impl for all of the settings defined in
// `cranelift-codegen/meta/src/isa/riscv/mod.rs`.
 
#[derive(Clone)]
/// Flags group `riscv`.
pub struct Flags {
    bytes: [u8; 2],
}
impl Flags {
    /// Create flags riscv settings group.
    #[allow(unused_variables)]
    pub fn new(shared: &settings::Flags, builder: Builder) -> Self {
        let bvec = builder.state_for("riscv");
        let mut riscv = Self { bytes: [0; 2] };
        debug_assert_eq!(bvec.len(), 1);
        riscv.bytes[0..1].copy_from_slice(&bvec);
        // Precompute #6.
        if shared.enable_simd() && riscv.supports_f() && riscv.supports_d() {
            riscv.bytes[0] |= 1 << 6;
        }
        // Precompute #7.
        if riscv.supports_a() && shared.enable_atomics() {
            riscv.bytes[0] |= 1 << 7;
        }
        // Precompute #8.
        if riscv.supports_d() && shared.enable_float() {
            riscv.bytes[1] |= 1 << 0;
        }
        // Precompute #9.
        if riscv.supports_f() && shared.enable_float() {
            riscv.bytes[1] |= 1 << 1;
        }
        // Precompute #10.
        if riscv.supports_m() && riscv.enable_m() {
            riscv.bytes[1] |= 1 << 2;
        }
        riscv
    }
}
/// User-defined settings.
#[allow(dead_code)]
impl Flags {
    /// Get a view of the boolean predicates.
    pub fn predicate_view(&self) -> crate::settings::PredicateView {
        crate::settings::PredicateView::new(&self.bytes[0..])
    }
    /// Dynamic numbered predicate getter.
    fn numbered_predicate(&self, p: usize) -> bool {
        self.bytes[0 + p / 8] & (1 << (p % 8)) != 0
    }
    /// CPU supports the 'M' extension (mul/div)
    pub fn supports_m(&self) -> bool {
        self.numbered_predicate(0)
    }
    /// CPU supports the 'A' extension (atomics)
    pub fn supports_a(&self) -> bool {
        self.numbered_predicate(1)
    }
    /// CPU supports the 'F' extension (float)
    pub fn supports_f(&self) -> bool {
        self.numbered_predicate(2)
    }
    /// CPU supports the 'D' extension (double)
    pub fn supports_d(&self) -> bool {
        self.numbered_predicate(3)
    }
    /// Enable the use of 'M' instructions if available
    pub fn enable_m(&self) -> bool {
        self.numbered_predicate(4)
    }
    /// Enable the 'RV32E' instruction set with only 16 registers
    pub fn enable_e(&self) -> bool {
        self.numbered_predicate(5)
    }
    /// Computed predicate `shared.enable_simd() && riscv.supports_f() && riscv.supports_d()`.
    pub fn full_float(&self) -> bool {
        self.numbered_predicate(6)
    }
    /// Computed predicate `riscv.supports_a() && shared.enable_atomics()`.
    pub fn use_a(&self) -> bool {
        self.numbered_predicate(7)
    }
    /// Computed predicate `riscv.supports_d() && shared.enable_float()`.
    pub fn use_d(&self) -> bool {
        self.numbered_predicate(8)
    }
    /// Computed predicate `riscv.supports_f() && shared.enable_float()`.
    pub fn use_f(&self) -> bool {
        self.numbered_predicate(9)
    }
    /// Computed predicate `riscv.supports_m() && riscv.enable_m()`.
    pub fn use_m(&self) -> bool {
        self.numbered_predicate(10)
    }
}
static DESCRIPTORS: [detail::Descriptor; 6] = [
    detail::Descriptor {
        name: "supports_m",
        offset: 0,
        detail: detail::Detail::Bool { bit: 0 },
    },
    detail::Descriptor {
        name: "supports_a",
        offset: 0,
        detail: detail::Detail::Bool { bit: 1 },
    },
    detail::Descriptor {
        name: "supports_f",
        offset: 0,
        detail: detail::Detail::Bool { bit: 2 },
    },
    detail::Descriptor {
        name: "supports_d",
        offset: 0,
        detail: detail::Detail::Bool { bit: 3 },
    },
    detail::Descriptor {
        name: "enable_m",
        offset: 0,
        detail: detail::Detail::Bool { bit: 4 },
    },
    detail::Descriptor {
        name: "enable_e",
        offset: 0,
        detail: detail::Detail::Bool { bit: 5 },
    },
];
static ENUMERATORS: [&str; 0] = [
];
static HASH_TABLE: [u16; 8] = [
    1,
    2,
    5,
    3,
    0,
    0xffff,
    0xffff,
    4,
];
static PRESETS: [(u8, u8); 0] = [
];
static TEMPLATE: detail::Template = detail::Template {
    name: "riscv",
    descriptors: &DESCRIPTORS,
    enumerators: &ENUMERATORS,
    hash_table: &HASH_TABLE,
    defaults: &[0x10],
    presets: &PRESETS,
};
/// Create a `settings::Builder` for the riscv settings group.
pub fn builder() -> Builder {
    Builder::new(&TEMPLATE)
}
impl fmt::Display for Flags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(f, "[riscv]")?;
        for d in &DESCRIPTORS {
            if !d.detail.is_preset() {
                write!(f, "{} = ", d.name)?;
                TEMPLATE.format_toml_value(d.detail, self.bytes[d.offset as usize], f)?;
                writeln!(f)?;
            }
        }
        Ok(())
    }
}

 //clude!(concat!(env!("OUT_DIR"), "/settings-riscv.rs"));

#[cfg(test)]
mod tests {
    use super::{builder, Flags};
    use crate::settings::{self, Configurable};
    use alloc::string::ToString;

    #[test]
    fn display_default() {
        let shared = settings::Flags::new(settings::builder());
        let b = builder();
        let f = Flags::new(&shared, b);
        assert_eq!(
            f.to_string(),
            "[riscv]\n\
             supports_m = false\n\
             supports_a = false\n\
             supports_f = false\n\
             supports_d = false\n\
             enable_m = true\n\
             enable_e = false\n"
        );
        // Predicates are not part of the Display output.
        assert_eq!(f.full_float(), false);
    }

    #[test]
    fn predicates() {
        let mut sb = settings::builder();
        sb.set("enable_simd", "true").unwrap();
        let shared = settings::Flags::new(sb);
        let mut b = builder();
        b.enable("supports_f").unwrap();
        b.enable("supports_d").unwrap();
        let f = Flags::new(&shared, b);
        assert_eq!(f.full_float(), true);

        let mut sb = settings::builder();
        sb.set("enable_simd", "false").unwrap();
        let shared = settings::Flags::new(sb);
        let mut b = builder();
        b.enable("supports_f").unwrap();
        b.enable("supports_d").unwrap();
        let f = Flags::new(&shared, b);
        assert_eq!(f.full_float(), false);
    }
}
